#!/usr/bin/env python3

"""
The need for this script arose when we did de novo RNA-Seq assembly using non-strand-specific
reads, then later got strand-specific reads from the same sample.  We wanted to use the stranded
data to re-orient the transcripts generated by the unstranded data.

This script uses a SAM file representing the alignment of reads against a set of reference
sequences and then reports the number of references which appear to be in the wrong orientation.

WARNING:  This was written for strand-specific libraries of the RF type.

http://onetipperday.blogspot.com/2012/04/understand-flag-code-of-sam-format.html

Better detailed version:
http://blog.nextgenetics.net/?e=18

Flags to check:

16 0x10 SEQ being reverse complemented
64 0x40 the first segment in the template
128 0x80 the last segment in the template
256 0x100 secondary alignment
512 0x200 not passing filters, such as platform/vendor quality controls
2048 0x800 supplementary alignment
   
EXAMPLE DATA

SN7001163:162:C4A1UACXX:1:1101:1174:2116        81      Locus_14841_Transcript_1__1_Confidence_0.750_Length_603 292     37      101M    =       294     -99     CTCGTCATTTCAATGCCCCCTCTCATATCAGAAGGAAAATCATGAGTGCTCCTTTGTCAAAAGAGCTGAGAGCAAAGTACAATGTGAGAAGTATGCCCATT   >BBDDDDDDDDDDDBDFFHHHHIIHJJJJJJJJJJJJJJIIJJJJJJJJJJJJJJIIIJJJJIJJJJJJJIJJJJJJJHJJJIJJJJJHHHHHFFFFFCCC   XT:A:U  NM:i:0  SM:i:37 AM:i:37 X0:i:1  X1:i:0  XM:i:0  XO:i:0  XG:i:0  MD:Z:101
flag   16 = True
flag   64 = True
flag  128 = False
flag  256 = False
flag  512 = False
flag 2048 = False

SN7001163:162:C4A1UACXX:1:1101:1174:2116        161     Locus_14841_Transcript_1__1_Confidence_0.750_Length_603 294     37      101M    =       292     99      CGTCATTTCAATGCCCCCTCTCATATCAGAAGGAAAATCATGAGTGCTCCTTTGTCAAAAGAGCTGAGAGCAAAGTACAATGTGAGAAGTATGCCCATTAG   BCBFFFFFHHHH?HIJJJJJJJJJJJJJJJJJJJJJJJJJJJJJHIJJJJGHIIHHIJJJJJJJJJIJJJJJHHHHHHFFFFFFFEEEEEEEEDDDDDDDC   XT:A:U  NM:i:1  SM:i:37 AM:i:37 X0:i:1  X1:i:0  XM:i:1  XO:i:0  XG:i:0  MD:Z:99C1
flag   16 = False
flag   64 = False
flag  128 = True
flag  256 = False
flag  512 = False
flag 2048 = False

"""

import argparse

from biocode import utils


def main():
    parser = argparse.ArgumentParser( description='Put a description of your script here')

    ## output file to be written
    parser.add_argument('-s', '--sam_file', type=str, required=True, help='Input SAM file with reads aligned to reference' )
    parser.add_argument('-fi', '--fasta_in', type=str, required=False, help='Path to a FASTA file representing sequences that were aligned against.  If this is passed, you should also pass the -fo argument' )
    parser.add_argument('-fo', '--fasta_out', type=str, required=False, help='If passed along with -fi, the orientation-corrected sequences will be written here.' )
    args = parser.parse_args()
    seqs = dict()

    if args.fasta_in is not None:
        seqs = utils.fasta_dict_from_file(args.fasta_in)

        if args.fasta_out is not None:
            out_fh = open(args.fasta_out, 'w')
        else:
            raise Exception("ERROR: You must pass a value for -fo if you pass -fi")

    total_read_mappings = 0
    last_transcript_id = None
    counts = { '1':{'T':0,'F':0}, '2':{'T':0,'F':0} }
    transcript_count = 0
    correct_orientation_count = 0
    incorrect_orientation_count = 0

    transcripts_to_correct = dict()

    for line in open(args.sam_file):
        if line.startswith('@'): continue
        
        cols = line.split("\t")
        if len(cols) < 5: continue

        flag = cols[1]

        # For an RF strand-specific library, the first segment in the template is 
        # the /1 mate (from the FASTQ naming convention)
        if int(flag) & 64:
            read_dir = '1'
        else:
            read_dir = '2'

        transcript_id = cols[2]
        total_read_mappings += 1

        if int(flag) & 16:
            seq_revcomped = 'T'
        else:
            seq_revcomped = 'F'

        #print("DEBUG: match:{2}, SEQ_revcomped={0}, read_dir={1}".format(seq_revcomped, read_dir, transcript_id))

        if transcript_id == last_transcript_id:
            counts[read_dir][seq_revcomped] += 1
        else:
            transcript_count += 1
            
            if last_transcript_id is not None:
                ## determine transcript orientation
                ## Given an RF library, the 1:T count should outnumber the 1:F one
                if counts['1']['T'] > counts['1']['F']:
                    correct_orientation_count += 1
                else:
                    incorrect_orientation_count += 1
                    transcripts_to_correct[last_transcript_id] = 1
                
                ## report counts
                print("{0}\t1-T:{1}\t1-F:{2}\t2-T:{3}\t2-F:{4}".format(last_transcript_id, counts['1']['T'], counts['1']['F'], counts['2']['T'], counts['2']['F']))

            ## reset
            last_transcript_id = transcript_id
            counts = { '1':{'T':0,'F':0}, '2':{'T':0,'F':0} }

    # deal with the last one
    ## determine transcript orientation
    ## Given an RF library, the 1:T count should outnumber the 1:F one
    if counts['1']['T'] > counts['1']['F']:
        correct_orientation_count += 1
    else:
        incorrect_orientation_count += 1
        transcripts_to_correct[last_transcript_id] = 1
                
    ## report counts
    print("{0}\t1-T:{1}\t1-F:{2}\t2-T:{3}\t2-F:{4}".format(last_transcript_id, counts['1']['T'], counts['1']['F'], counts['2']['T'], counts['2']['F']))



    for seq_id in seqs:
        seq = seqs[seq_id]

        if seq_id in transcripts_to_correct:
            seq['s'] = utils.reverse_complement(seq['s'])

        out_fh.write(">{0} {2}\n{1}\n".format(seq_id, utils.wrapped_fasta(seq['s']), seq['h']))

    print("Total transcripts: {0}".format(transcript_count))
    print("Total reads mapped: {0}".format(total_read_mappings))
    print("Transcripts in correct orientation: {0}".format(correct_orientation_count))
    print("Transcripts in reverse orientation: {0}".format(incorrect_orientation_count))
#    print("R1 reads mapped where SEQrevcomp=FALSE: {0}".format(dir1_reads_mapped))
#    print("R2 reads mapped where SEQrevcomp=TRUE: {0}".format(dir2_reads_mapped))
    
        
    



if __name__ == '__main__':
    main()







