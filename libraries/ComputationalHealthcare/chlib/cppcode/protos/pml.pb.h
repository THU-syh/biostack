// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pml.proto

#ifndef PROTOBUF_pml_2eproto__INCLUDED
#define PROTOBUF_pml_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "penums.pb.h"
#include "pvisit.pb.h"
#include "pstat.pb.h"
#include "pn1.pb.h"
// @@protoc_insertion_point(includes)

namespace comphealth {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pml_2eproto();
void protobuf_AssignDesc_pml_2eproto();
void protobuf_ShutdownFile_pml_2eproto();

class PDXCLASSIFIER;
class NPRESULT;
class Labels;
class Exclusions;
class QUERY;

// ===================================================================

class PDXCLASSIFIER : public ::google::protobuf::Message {
 public:
  PDXCLASSIFIER();
  virtual ~PDXCLASSIFIER();

  PDXCLASSIFIER(const PDXCLASSIFIER& from);

  inline PDXCLASSIFIER& operator=(const PDXCLASSIFIER& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PDXCLASSIFIER& default_instance();

  void Swap(PDXCLASSIFIER* other);

  // implements Message ----------------------------------------------

  PDXCLASSIFIER* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PDXCLASSIFIER& from);
  void MergeFrom(const PDXCLASSIFIER& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string index_code = 1;
  inline bool has_index_code() const;
  inline void clear_index_code();
  static const int kIndexCodeFieldNumber = 1;
  inline const ::std::string& index_code() const;
  inline void set_index_code(const ::std::string& value);
  inline void set_index_code(const char* value);
  inline void set_index_code(const char* value, size_t size);
  inline ::std::string* mutable_index_code();
  inline ::std::string* release_index_code();
  inline void set_allocated_index_code(::std::string* index_code);

  // required .comphealth.PAGG patients = 2;
  inline bool has_patients() const;
  inline void clear_patients();
  static const int kPatientsFieldNumber = 2;
  inline const ::comphealth::PAGG& patients() const;
  inline ::comphealth::PAGG* mutable_patients();
  inline ::comphealth::PAGG* release_patients();
  inline void set_allocated_patients(::comphealth::PAGG* patients);

  // required .comphealth.AGG index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline const ::comphealth::AGG& index() const;
  inline ::comphealth::AGG* mutable_index();
  inline ::comphealth::AGG* release_index();
  inline void set_allocated_index(::comphealth::AGG* index);

  // optional .comphealth.AGG sub = 4;
  inline bool has_sub() const;
  inline void clear_sub();
  static const int kSubFieldNumber = 4;
  inline const ::comphealth::AGG& sub() const;
  inline ::comphealth::AGG* mutable_sub();
  inline ::comphealth::AGG* release_sub();
  inline void set_allocated_sub(::comphealth::AGG* sub);

  // repeated .comphealth.Labels labels = 5;
  inline int labels_size() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 5;
  inline const ::comphealth::Labels& labels(int index) const;
  inline ::comphealth::Labels* mutable_labels(int index);
  inline ::comphealth::Labels* add_labels();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::Labels >&
      labels() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::Labels >*
      mutable_labels();

  // repeated .comphealth.Exclusions exclusions = 6;
  inline int exclusions_size() const;
  inline void clear_exclusions();
  static const int kExclusionsFieldNumber = 6;
  inline const ::comphealth::Exclusions& exclusions(int index) const;
  inline ::comphealth::Exclusions* mutable_exclusions(int index);
  inline ::comphealth::Exclusions* add_exclusions();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::Exclusions >&
      exclusions() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::Exclusions >*
      mutable_exclusions();

  // required int32 count = 7;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 7;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:comphealth.PDXCLASSIFIER)
 private:
  inline void set_has_index_code();
  inline void clear_has_index_code();
  inline void set_has_patients();
  inline void clear_has_patients();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_sub();
  inline void clear_has_sub();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* index_code_;
  ::comphealth::PAGG* patients_;
  ::comphealth::AGG* index_;
  ::comphealth::AGG* sub_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::Labels > labels_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::Exclusions > exclusions_;
  ::google::protobuf::int32 count_;
  friend void  protobuf_AddDesc_pml_2eproto();
  friend void protobuf_AssignDesc_pml_2eproto();
  friend void protobuf_ShutdownFile_pml_2eproto();

  void InitAsDefaultInstance();
  static PDXCLASSIFIER* default_instance_;
};
// -------------------------------------------------------------------

class NPRESULT : public ::google::protobuf::Message {
 public:
  NPRESULT();
  virtual ~NPRESULT();

  NPRESULT(const NPRESULT& from);

  inline NPRESULT& operator=(const NPRESULT& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NPRESULT& default_instance();

  void Swap(NPRESULT* other);

  // implements Message ----------------------------------------------

  NPRESULT* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NPRESULT& from);
  void MergeFrom(const NPRESULT& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .comphealth.PAGG patients = 2;
  inline bool has_patients() const;
  inline void clear_patients();
  static const int kPatientsFieldNumber = 2;
  inline const ::comphealth::PAGG& patients() const;
  inline ::comphealth::PAGG* mutable_patients();
  inline ::comphealth::PAGG* release_patients();
  inline void set_allocated_patients(::comphealth::PAGG* patients);

  // required .comphealth.AGG index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline const ::comphealth::AGG& index() const;
  inline ::comphealth::AGG* mutable_index();
  inline ::comphealth::AGG* release_index();
  inline void set_allocated_index(::comphealth::AGG* index);

  // optional .comphealth.AGG future = 4;
  inline bool has_future() const;
  inline void clear_future();
  static const int kFutureFieldNumber = 4;
  inline const ::comphealth::AGG& future() const;
  inline ::comphealth::AGG* mutable_future();
  inline ::comphealth::AGG* release_future();
  inline void set_allocated_future(::comphealth::AGG* future);

  // repeated .comphealth.QUERY query = 6;
  inline int query_size() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 6;
  inline const ::comphealth::QUERY& query(int index) const;
  inline ::comphealth::QUERY* mutable_query(int index);
  inline ::comphealth::QUERY* add_query();
  inline const ::google::protobuf::RepeatedPtrField< ::comphealth::QUERY >&
      query() const;
  inline ::google::protobuf::RepeatedPtrField< ::comphealth::QUERY >*
      mutable_query();

  // required .comphealth.IntHist deltah = 5;
  inline bool has_deltah() const;
  inline void clear_deltah();
  static const int kDeltahFieldNumber = 5;
  inline const ::comphealth::IntHist& deltah() const;
  inline ::comphealth::IntHist* mutable_deltah();
  inline ::comphealth::IntHist* release_deltah();
  inline void set_allocated_deltah(::comphealth::IntHist* deltah);

  // required int32 neighbors = 7;
  inline bool has_neighbors() const;
  inline void clear_neighbors();
  static const int kNeighborsFieldNumber = 7;
  inline ::google::protobuf::int32 neighbors() const;
  inline void set_neighbors(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:comphealth.NPRESULT)
 private:
  inline void set_has_patients();
  inline void clear_has_patients();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_future();
  inline void clear_has_future();
  inline void set_has_deltah();
  inline void clear_has_deltah();
  inline void set_has_neighbors();
  inline void clear_has_neighbors();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::comphealth::PAGG* patients_;
  ::comphealth::AGG* index_;
  ::comphealth::AGG* future_;
  ::google::protobuf::RepeatedPtrField< ::comphealth::QUERY > query_;
  ::comphealth::IntHist* deltah_;
  ::google::protobuf::int32 neighbors_;
  friend void  protobuf_AddDesc_pml_2eproto();
  friend void protobuf_AssignDesc_pml_2eproto();
  friend void protobuf_ShutdownFile_pml_2eproto();

  void InitAsDefaultInstance();
  static NPRESULT* default_instance_;
};
// -------------------------------------------------------------------

class Labels : public ::google::protobuf::Message {
 public:
  Labels();
  virtual ~Labels();

  Labels(const Labels& from);

  inline Labels& operator=(const Labels& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Labels& default_instance();

  void Swap(Labels* other);

  // implements Message ----------------------------------------------

  Labels* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Labels& from);
  void MergeFrom(const Labels& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // optional string label = 3;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 3;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // @@protoc_insertion_point(class_scope:comphealth.Labels)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_label();
  inline void clear_has_label();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* label_;
  ::google::protobuf::int32 count_;
  friend void  protobuf_AddDesc_pml_2eproto();
  friend void protobuf_AssignDesc_pml_2eproto();
  friend void protobuf_ShutdownFile_pml_2eproto();

  void InitAsDefaultInstance();
  static Labels* default_instance_;
};
// -------------------------------------------------------------------

class Exclusions : public ::google::protobuf::Message {
 public:
  Exclusions();
  virtual ~Exclusions();

  Exclusions(const Exclusions& from);

  inline Exclusions& operator=(const Exclusions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Exclusions& default_instance();

  void Swap(Exclusions* other);

  // implements Message ----------------------------------------------

  Exclusions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Exclusions& from);
  void MergeFrom(const Exclusions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // optional string reason = 3;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 3;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  inline void set_allocated_reason(::std::string* reason);

  // @@protoc_insertion_point(class_scope:comphealth.Exclusions)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_reason();
  inline void clear_has_reason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* reason_;
  ::google::protobuf::int32 count_;
  friend void  protobuf_AddDesc_pml_2eproto();
  friend void protobuf_AssignDesc_pml_2eproto();
  friend void protobuf_ShutdownFile_pml_2eproto();

  void InitAsDefaultInstance();
  static Exclusions* default_instance_;
};
// -------------------------------------------------------------------

class QUERY : public ::google::protobuf::Message {
 public:
  QUERY();
  virtual ~QUERY();

  QUERY(const QUERY& from);

  inline QUERY& operator=(const QUERY& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QUERY& default_instance();

  void Swap(QUERY* other);

  // implements Message ----------------------------------------------

  QUERY* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QUERY& from);
  void MergeFrom(const QUERY& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float weight = 1;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 1;
  inline float weight() const;
  inline void set_weight(float value);

  // optional string fname = 3;
  inline bool has_fname() const;
  inline void clear_fname();
  static const int kFnameFieldNumber = 3;
  inline const ::std::string& fname() const;
  inline void set_fname(const ::std::string& value);
  inline void set_fname(const char* value);
  inline void set_fname(const char* value, size_t size);
  inline ::std::string* mutable_fname();
  inline ::std::string* release_fname();
  inline void set_allocated_fname(::std::string* fname);

  // @@protoc_insertion_point(class_scope:comphealth.QUERY)
 private:
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_fname();
  inline void clear_has_fname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* fname_;
  float weight_;
  friend void  protobuf_AddDesc_pml_2eproto();
  friend void protobuf_AssignDesc_pml_2eproto();
  friend void protobuf_ShutdownFile_pml_2eproto();

  void InitAsDefaultInstance();
  static QUERY* default_instance_;
};
// ===================================================================


// ===================================================================

// PDXCLASSIFIER

// required string index_code = 1;
inline bool PDXCLASSIFIER::has_index_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PDXCLASSIFIER::set_has_index_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PDXCLASSIFIER::clear_has_index_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PDXCLASSIFIER::clear_index_code() {
  if (index_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    index_code_->clear();
  }
  clear_has_index_code();
}
inline const ::std::string& PDXCLASSIFIER::index_code() const {
  // @@protoc_insertion_point(field_get:comphealth.PDXCLASSIFIER.index_code)
  return *index_code_;
}
inline void PDXCLASSIFIER::set_index_code(const ::std::string& value) {
  set_has_index_code();
  if (index_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    index_code_ = new ::std::string;
  }
  index_code_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.PDXCLASSIFIER.index_code)
}
inline void PDXCLASSIFIER::set_index_code(const char* value) {
  set_has_index_code();
  if (index_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    index_code_ = new ::std::string;
  }
  index_code_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.PDXCLASSIFIER.index_code)
}
inline void PDXCLASSIFIER::set_index_code(const char* value, size_t size) {
  set_has_index_code();
  if (index_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    index_code_ = new ::std::string;
  }
  index_code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.PDXCLASSIFIER.index_code)
}
inline ::std::string* PDXCLASSIFIER::mutable_index_code() {
  set_has_index_code();
  if (index_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    index_code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.PDXCLASSIFIER.index_code)
  return index_code_;
}
inline ::std::string* PDXCLASSIFIER::release_index_code() {
  clear_has_index_code();
  if (index_code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = index_code_;
    index_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PDXCLASSIFIER::set_allocated_index_code(::std::string* index_code) {
  if (index_code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete index_code_;
  }
  if (index_code) {
    set_has_index_code();
    index_code_ = index_code;
  } else {
    clear_has_index_code();
    index_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PDXCLASSIFIER.index_code)
}

// required .comphealth.PAGG patients = 2;
inline bool PDXCLASSIFIER::has_patients() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PDXCLASSIFIER::set_has_patients() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PDXCLASSIFIER::clear_has_patients() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PDXCLASSIFIER::clear_patients() {
  if (patients_ != NULL) patients_->::comphealth::PAGG::Clear();
  clear_has_patients();
}
inline const ::comphealth::PAGG& PDXCLASSIFIER::patients() const {
  // @@protoc_insertion_point(field_get:comphealth.PDXCLASSIFIER.patients)
  return patients_ != NULL ? *patients_ : *default_instance_->patients_;
}
inline ::comphealth::PAGG* PDXCLASSIFIER::mutable_patients() {
  set_has_patients();
  if (patients_ == NULL) patients_ = new ::comphealth::PAGG;
  // @@protoc_insertion_point(field_mutable:comphealth.PDXCLASSIFIER.patients)
  return patients_;
}
inline ::comphealth::PAGG* PDXCLASSIFIER::release_patients() {
  clear_has_patients();
  ::comphealth::PAGG* temp = patients_;
  patients_ = NULL;
  return temp;
}
inline void PDXCLASSIFIER::set_allocated_patients(::comphealth::PAGG* patients) {
  delete patients_;
  patients_ = patients;
  if (patients) {
    set_has_patients();
  } else {
    clear_has_patients();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PDXCLASSIFIER.patients)
}

// required .comphealth.AGG index = 3;
inline bool PDXCLASSIFIER::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PDXCLASSIFIER::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PDXCLASSIFIER::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PDXCLASSIFIER::clear_index() {
  if (index_ != NULL) index_->::comphealth::AGG::Clear();
  clear_has_index();
}
inline const ::comphealth::AGG& PDXCLASSIFIER::index() const {
  // @@protoc_insertion_point(field_get:comphealth.PDXCLASSIFIER.index)
  return index_ != NULL ? *index_ : *default_instance_->index_;
}
inline ::comphealth::AGG* PDXCLASSIFIER::mutable_index() {
  set_has_index();
  if (index_ == NULL) index_ = new ::comphealth::AGG;
  // @@protoc_insertion_point(field_mutable:comphealth.PDXCLASSIFIER.index)
  return index_;
}
inline ::comphealth::AGG* PDXCLASSIFIER::release_index() {
  clear_has_index();
  ::comphealth::AGG* temp = index_;
  index_ = NULL;
  return temp;
}
inline void PDXCLASSIFIER::set_allocated_index(::comphealth::AGG* index) {
  delete index_;
  index_ = index;
  if (index) {
    set_has_index();
  } else {
    clear_has_index();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PDXCLASSIFIER.index)
}

// optional .comphealth.AGG sub = 4;
inline bool PDXCLASSIFIER::has_sub() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PDXCLASSIFIER::set_has_sub() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PDXCLASSIFIER::clear_has_sub() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PDXCLASSIFIER::clear_sub() {
  if (sub_ != NULL) sub_->::comphealth::AGG::Clear();
  clear_has_sub();
}
inline const ::comphealth::AGG& PDXCLASSIFIER::sub() const {
  // @@protoc_insertion_point(field_get:comphealth.PDXCLASSIFIER.sub)
  return sub_ != NULL ? *sub_ : *default_instance_->sub_;
}
inline ::comphealth::AGG* PDXCLASSIFIER::mutable_sub() {
  set_has_sub();
  if (sub_ == NULL) sub_ = new ::comphealth::AGG;
  // @@protoc_insertion_point(field_mutable:comphealth.PDXCLASSIFIER.sub)
  return sub_;
}
inline ::comphealth::AGG* PDXCLASSIFIER::release_sub() {
  clear_has_sub();
  ::comphealth::AGG* temp = sub_;
  sub_ = NULL;
  return temp;
}
inline void PDXCLASSIFIER::set_allocated_sub(::comphealth::AGG* sub) {
  delete sub_;
  sub_ = sub;
  if (sub) {
    set_has_sub();
  } else {
    clear_has_sub();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.PDXCLASSIFIER.sub)
}

// repeated .comphealth.Labels labels = 5;
inline int PDXCLASSIFIER::labels_size() const {
  return labels_.size();
}
inline void PDXCLASSIFIER::clear_labels() {
  labels_.Clear();
}
inline const ::comphealth::Labels& PDXCLASSIFIER::labels(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.PDXCLASSIFIER.labels)
  return labels_.Get(index);
}
inline ::comphealth::Labels* PDXCLASSIFIER::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.PDXCLASSIFIER.labels)
  return labels_.Mutable(index);
}
inline ::comphealth::Labels* PDXCLASSIFIER::add_labels() {
  // @@protoc_insertion_point(field_add:comphealth.PDXCLASSIFIER.labels)
  return labels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::Labels >&
PDXCLASSIFIER::labels() const {
  // @@protoc_insertion_point(field_list:comphealth.PDXCLASSIFIER.labels)
  return labels_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::Labels >*
PDXCLASSIFIER::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.PDXCLASSIFIER.labels)
  return &labels_;
}

// repeated .comphealth.Exclusions exclusions = 6;
inline int PDXCLASSIFIER::exclusions_size() const {
  return exclusions_.size();
}
inline void PDXCLASSIFIER::clear_exclusions() {
  exclusions_.Clear();
}
inline const ::comphealth::Exclusions& PDXCLASSIFIER::exclusions(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.PDXCLASSIFIER.exclusions)
  return exclusions_.Get(index);
}
inline ::comphealth::Exclusions* PDXCLASSIFIER::mutable_exclusions(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.PDXCLASSIFIER.exclusions)
  return exclusions_.Mutable(index);
}
inline ::comphealth::Exclusions* PDXCLASSIFIER::add_exclusions() {
  // @@protoc_insertion_point(field_add:comphealth.PDXCLASSIFIER.exclusions)
  return exclusions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::Exclusions >&
PDXCLASSIFIER::exclusions() const {
  // @@protoc_insertion_point(field_list:comphealth.PDXCLASSIFIER.exclusions)
  return exclusions_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::Exclusions >*
PDXCLASSIFIER::mutable_exclusions() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.PDXCLASSIFIER.exclusions)
  return &exclusions_;
}

// required int32 count = 7;
inline bool PDXCLASSIFIER::has_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PDXCLASSIFIER::set_has_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PDXCLASSIFIER::clear_has_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PDXCLASSIFIER::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 PDXCLASSIFIER::count() const {
  // @@protoc_insertion_point(field_get:comphealth.PDXCLASSIFIER.count)
  return count_;
}
inline void PDXCLASSIFIER::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:comphealth.PDXCLASSIFIER.count)
}

// -------------------------------------------------------------------

// NPRESULT

// required .comphealth.PAGG patients = 2;
inline bool NPRESULT::has_patients() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NPRESULT::set_has_patients() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NPRESULT::clear_has_patients() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NPRESULT::clear_patients() {
  if (patients_ != NULL) patients_->::comphealth::PAGG::Clear();
  clear_has_patients();
}
inline const ::comphealth::PAGG& NPRESULT::patients() const {
  // @@protoc_insertion_point(field_get:comphealth.NPRESULT.patients)
  return patients_ != NULL ? *patients_ : *default_instance_->patients_;
}
inline ::comphealth::PAGG* NPRESULT::mutable_patients() {
  set_has_patients();
  if (patients_ == NULL) patients_ = new ::comphealth::PAGG;
  // @@protoc_insertion_point(field_mutable:comphealth.NPRESULT.patients)
  return patients_;
}
inline ::comphealth::PAGG* NPRESULT::release_patients() {
  clear_has_patients();
  ::comphealth::PAGG* temp = patients_;
  patients_ = NULL;
  return temp;
}
inline void NPRESULT::set_allocated_patients(::comphealth::PAGG* patients) {
  delete patients_;
  patients_ = patients;
  if (patients) {
    set_has_patients();
  } else {
    clear_has_patients();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.NPRESULT.patients)
}

// required .comphealth.AGG index = 3;
inline bool NPRESULT::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NPRESULT::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NPRESULT::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NPRESULT::clear_index() {
  if (index_ != NULL) index_->::comphealth::AGG::Clear();
  clear_has_index();
}
inline const ::comphealth::AGG& NPRESULT::index() const {
  // @@protoc_insertion_point(field_get:comphealth.NPRESULT.index)
  return index_ != NULL ? *index_ : *default_instance_->index_;
}
inline ::comphealth::AGG* NPRESULT::mutable_index() {
  set_has_index();
  if (index_ == NULL) index_ = new ::comphealth::AGG;
  // @@protoc_insertion_point(field_mutable:comphealth.NPRESULT.index)
  return index_;
}
inline ::comphealth::AGG* NPRESULT::release_index() {
  clear_has_index();
  ::comphealth::AGG* temp = index_;
  index_ = NULL;
  return temp;
}
inline void NPRESULT::set_allocated_index(::comphealth::AGG* index) {
  delete index_;
  index_ = index;
  if (index) {
    set_has_index();
  } else {
    clear_has_index();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.NPRESULT.index)
}

// optional .comphealth.AGG future = 4;
inline bool NPRESULT::has_future() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NPRESULT::set_has_future() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NPRESULT::clear_has_future() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NPRESULT::clear_future() {
  if (future_ != NULL) future_->::comphealth::AGG::Clear();
  clear_has_future();
}
inline const ::comphealth::AGG& NPRESULT::future() const {
  // @@protoc_insertion_point(field_get:comphealth.NPRESULT.future)
  return future_ != NULL ? *future_ : *default_instance_->future_;
}
inline ::comphealth::AGG* NPRESULT::mutable_future() {
  set_has_future();
  if (future_ == NULL) future_ = new ::comphealth::AGG;
  // @@protoc_insertion_point(field_mutable:comphealth.NPRESULT.future)
  return future_;
}
inline ::comphealth::AGG* NPRESULT::release_future() {
  clear_has_future();
  ::comphealth::AGG* temp = future_;
  future_ = NULL;
  return temp;
}
inline void NPRESULT::set_allocated_future(::comphealth::AGG* future) {
  delete future_;
  future_ = future;
  if (future) {
    set_has_future();
  } else {
    clear_has_future();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.NPRESULT.future)
}

// repeated .comphealth.QUERY query = 6;
inline int NPRESULT::query_size() const {
  return query_.size();
}
inline void NPRESULT::clear_query() {
  query_.Clear();
}
inline const ::comphealth::QUERY& NPRESULT::query(int index) const {
  // @@protoc_insertion_point(field_get:comphealth.NPRESULT.query)
  return query_.Get(index);
}
inline ::comphealth::QUERY* NPRESULT::mutable_query(int index) {
  // @@protoc_insertion_point(field_mutable:comphealth.NPRESULT.query)
  return query_.Mutable(index);
}
inline ::comphealth::QUERY* NPRESULT::add_query() {
  // @@protoc_insertion_point(field_add:comphealth.NPRESULT.query)
  return query_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::comphealth::QUERY >&
NPRESULT::query() const {
  // @@protoc_insertion_point(field_list:comphealth.NPRESULT.query)
  return query_;
}
inline ::google::protobuf::RepeatedPtrField< ::comphealth::QUERY >*
NPRESULT::mutable_query() {
  // @@protoc_insertion_point(field_mutable_list:comphealth.NPRESULT.query)
  return &query_;
}

// required .comphealth.IntHist deltah = 5;
inline bool NPRESULT::has_deltah() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NPRESULT::set_has_deltah() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NPRESULT::clear_has_deltah() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NPRESULT::clear_deltah() {
  if (deltah_ != NULL) deltah_->::comphealth::IntHist::Clear();
  clear_has_deltah();
}
inline const ::comphealth::IntHist& NPRESULT::deltah() const {
  // @@protoc_insertion_point(field_get:comphealth.NPRESULT.deltah)
  return deltah_ != NULL ? *deltah_ : *default_instance_->deltah_;
}
inline ::comphealth::IntHist* NPRESULT::mutable_deltah() {
  set_has_deltah();
  if (deltah_ == NULL) deltah_ = new ::comphealth::IntHist;
  // @@protoc_insertion_point(field_mutable:comphealth.NPRESULT.deltah)
  return deltah_;
}
inline ::comphealth::IntHist* NPRESULT::release_deltah() {
  clear_has_deltah();
  ::comphealth::IntHist* temp = deltah_;
  deltah_ = NULL;
  return temp;
}
inline void NPRESULT::set_allocated_deltah(::comphealth::IntHist* deltah) {
  delete deltah_;
  deltah_ = deltah;
  if (deltah) {
    set_has_deltah();
  } else {
    clear_has_deltah();
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.NPRESULT.deltah)
}

// required int32 neighbors = 7;
inline bool NPRESULT::has_neighbors() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NPRESULT::set_has_neighbors() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NPRESULT::clear_has_neighbors() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NPRESULT::clear_neighbors() {
  neighbors_ = 0;
  clear_has_neighbors();
}
inline ::google::protobuf::int32 NPRESULT::neighbors() const {
  // @@protoc_insertion_point(field_get:comphealth.NPRESULT.neighbors)
  return neighbors_;
}
inline void NPRESULT::set_neighbors(::google::protobuf::int32 value) {
  set_has_neighbors();
  neighbors_ = value;
  // @@protoc_insertion_point(field_set:comphealth.NPRESULT.neighbors)
}

// -------------------------------------------------------------------

// Labels

// required int32 count = 1;
inline bool Labels::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Labels::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Labels::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Labels::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 Labels::count() const {
  // @@protoc_insertion_point(field_get:comphealth.Labels.count)
  return count_;
}
inline void Labels::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:comphealth.Labels.count)
}

// optional string label = 3;
inline bool Labels::has_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Labels::set_has_label() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Labels::clear_has_label() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Labels::clear_label() {
  if (label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& Labels::label() const {
  // @@protoc_insertion_point(field_get:comphealth.Labels.label)
  return *label_;
}
inline void Labels::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  label_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.Labels.label)
}
inline void Labels::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  label_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.Labels.label)
}
inline void Labels::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.Labels.label)
}
inline ::std::string* Labels::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    label_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.Labels.label)
  return label_;
}
inline ::std::string* Labels::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Labels::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.Labels.label)
}

// -------------------------------------------------------------------

// Exclusions

// required int32 count = 1;
inline bool Exclusions::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Exclusions::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Exclusions::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Exclusions::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 Exclusions::count() const {
  // @@protoc_insertion_point(field_get:comphealth.Exclusions.count)
  return count_;
}
inline void Exclusions::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:comphealth.Exclusions.count)
}

// optional string reason = 3;
inline bool Exclusions::has_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Exclusions::set_has_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Exclusions::clear_has_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Exclusions::clear_reason() {
  if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_->clear();
  }
  clear_has_reason();
}
inline const ::std::string& Exclusions::reason() const {
  // @@protoc_insertion_point(field_get:comphealth.Exclusions.reason)
  return *reason_;
}
inline void Exclusions::set_reason(const ::std::string& value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.Exclusions.reason)
}
inline void Exclusions::set_reason(const char* value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.Exclusions.reason)
}
inline void Exclusions::set_reason(const char* value, size_t size) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.Exclusions.reason)
}
inline ::std::string* Exclusions::mutable_reason() {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reason_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.Exclusions.reason)
  return reason_;
}
inline ::std::string* Exclusions::release_reason() {
  clear_has_reason();
  if (reason_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = reason_;
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Exclusions::set_allocated_reason(::std::string* reason) {
  if (reason_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete reason_;
  }
  if (reason) {
    set_has_reason();
    reason_ = reason;
  } else {
    clear_has_reason();
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.Exclusions.reason)
}

// -------------------------------------------------------------------

// QUERY

// required float weight = 1;
inline bool QUERY::has_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QUERY::set_has_weight() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QUERY::clear_has_weight() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QUERY::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline float QUERY::weight() const {
  // @@protoc_insertion_point(field_get:comphealth.QUERY.weight)
  return weight_;
}
inline void QUERY::set_weight(float value) {
  set_has_weight();
  weight_ = value;
  // @@protoc_insertion_point(field_set:comphealth.QUERY.weight)
}

// optional string fname = 3;
inline bool QUERY::has_fname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void QUERY::set_has_fname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void QUERY::clear_has_fname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void QUERY::clear_fname() {
  if (fname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fname_->clear();
  }
  clear_has_fname();
}
inline const ::std::string& QUERY::fname() const {
  // @@protoc_insertion_point(field_get:comphealth.QUERY.fname)
  return *fname_;
}
inline void QUERY::set_fname(const ::std::string& value) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fname_ = new ::std::string;
  }
  fname_->assign(value);
  // @@protoc_insertion_point(field_set:comphealth.QUERY.fname)
}
inline void QUERY::set_fname(const char* value) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fname_ = new ::std::string;
  }
  fname_->assign(value);
  // @@protoc_insertion_point(field_set_char:comphealth.QUERY.fname)
}
inline void QUERY::set_fname(const char* value, size_t size) {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fname_ = new ::std::string;
  }
  fname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:comphealth.QUERY.fname)
}
inline ::std::string* QUERY::mutable_fname() {
  set_has_fname();
  if (fname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    fname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:comphealth.QUERY.fname)
  return fname_;
}
inline ::std::string* QUERY::release_fname() {
  clear_has_fname();
  if (fname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = fname_;
    fname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void QUERY::set_allocated_fname(::std::string* fname) {
  if (fname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete fname_;
  }
  if (fname) {
    set_has_fname();
    fname_ = fname;
  } else {
    clear_has_fname();
    fname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:comphealth.QUERY.fname)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace comphealth

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pml_2eproto__INCLUDED
